I'll provide a detailed implementation plan for transforming your graph application into a multi-user connected experience with individual and combined graphs, along with graph data science capabilities.
Multi-User Graph Application Implementation Plan
Overview
This plan outlines how to transform your existing graph application into a collaborative, multi-user experience with robust graph data science capabilities. The implementation will enable:
1.	User authentication and accounts
2.	Individual user graphs
3.	Ability to share and combine graphs
4.	Real-time graph collaboration
5.	Graph data science and analytics for both individual and combined graphs
Phase 1: User Authentication System
Step 1: Create Authentication Store
Create a client-side authentication store using Zustand:
// client/src/stores/auth.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
interface User {
  id: string;
  username: string;
  email: string;
}
interface AuthState {
  token: string | null;
  user: User | null;
  isAuthenticated: boolean;
  login: (token: string, user: User) => void;
  logout: () => void;
}
export const useAuthStore = create<AuthState>()(
  persist(
    (set) => ({
      token: null,
      user: null,
      isAuthenticated: false,
      login: (token, user) => set({ token, user, isAuthenticated: true }),
      logout: () => set({ token: null, user: null, isAuthenticated: false }),
    }),
    { name: 'auth-storage' }
  )
);
Step 2: Create Authentication API Endpoints
Implement server-side authentication:
// server/auth.ts
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { db } from './database';
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';
export async function registerUser(username: string, email: string, password: string) {
  const hashedPassword = await bcrypt.hash(password, 10);
  
  const user = await db.query(
    'INSERT INTO users (username, email, password) VALUES ($1, $2, $3) RETURNING id, username, email',
    [username, email, hashedPassword]
  );
  
  const token = jwt.sign({ userId: user.rows[0].id }, JWT_SECRET, { expiresIn: '7d' });
  
  return { user: user.rows[0], token };
}
export async function loginUser(email: string, password: string) {
  const result = await db.query('SELECT * FROM users WHERE email = $1', [email]);
  
  if (result.rows.length === 0) {
    throw new Error('Invalid credentials');
  }
  
  const user = result.rows[0];
  const validPassword = await bcrypt.compare(password, user.password);
  
  if (!validPassword) {
    throw new Error('Invalid credentials');
  }
  
  const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '7d' });
  
  return { 
    user: { id: user.id, username: user.username, email: user.email },
    token 
  };
}
export function authenticateToken(token: string) {
  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    return decoded;
  } catch (err) {
    throw new Error('Invalid token');
  }
}
Step 3: Create Authentication Routes
Add routes for login/register:
// Update server/routes.ts to include these routes
app.post('/api/auth/register', async (req, res) => {
  try {
    const { username, email, password } = req.body;
    const result = await registerUser(username, email, password);
    res.json(result);
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
});
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    const result = await loginUser(email, password);
    res.json(result);
  } catch (error) {
    res.status(401).json({ message: error.message });
  }
});
Step 4: Create Authentication Components
Create authentication UI components:
// client/src/pages/Auth.tsx
import React, { useState } from 'react';
import { useAuthStore } from '@/stores/auth';
import { useLocation } from 'wouter';
export default function Auth() {
  const [isLogin, setIsLogin] = useState(true);
  const [email, setEmail] = useState('');
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  
  const { login } = useAuthStore();
  const [, navigate] = useLocation();
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    
    try {
      const endpoint = isLogin ? '/api/auth/login' : '/api/auth/register';
      const body = isLogin 
        ? { email, password } 
        : { username, email, password };
      
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
      
      const data = await response.json();
      
      if (!response.ok) {
        throw new Error(data.message || 'Authentication failed');
      }
      
      login(data.token, data.user);
      navigate('/');
    } catch (err) {
      setError(err.message);
    }
  };
  
  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-50">
      <div className="w-full max-w-md p-8 space-y-6 bg-white rounded-lg shadow">
        <h1 className="text-2xl font-bold text-center">
          {isLogin ? 'Login' : 'Create an Account'}
        </h1>
        
        {error && (
          <div className="p-3 text-sm text-red-600 bg-red-100 rounded">
            {error}
          </div>
        )}
        
        <form onSubmit={handleSubmit} className="space-y-4">
          {!isLogin && (
            <div>
              <label className="block text-sm font-medium text-gray-700">Username</label>
              <input
                type="text"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
                className="w-full px-3 py-2 mt-1 border rounded-md"
                required
              />
            </div>
          )}
          
          <div>
            <label className="block text-sm font-medium text-gray-700">Email</label>
            <input
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="w-full px-3 py-2 mt-1 border rounded-md"
              required
            />
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700">Password</label>
            <input
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="w-full px-3 py-2 mt-1 border rounded-md"
              required
            />
          </div>
          
          <button
            type="submit"
            className="w-full py-2 text-white bg-blue-600 rounded-md hover:bg-blue-700"
          >
            {isLogin ? 'Login' : 'Register'}
          </button>
        </form>
        
        <div className="text-center">
          <button
            onClick={() => setIsLogin(!isLogin)}
            className="text-sm text-blue-600 hover:underline"
          >
            {isLogin ? 'Need an account? Register' : 'Already have an account? Login'}
          </button>
        </div>
      </div>
    </div>
  );
}
Phase 2: Database Schema for Multi-User Graphs
Step 1: Create Multi-User Schema
Update your database schema:
// shared/schema.ts - Add these new schema types
// User schemas
export const userSchema = z.object({
  id: z.string().uuid(),
  username: z.string().min(3).max(50),
  email: z.string().email(),
  createdAt: z.date()
});
// Individual user graph schema
export const userGraphSchema = z.object({
  id: z.string().uuid(),
  userId: z.string().uuid(),
  name: z.string(),
  description: z.string().optional(),
  isPublic: z.boolean().default(false),
  nodes: z.array(nodeSchema),
  edges: z.array(edgeSchema),
  createdAt: z.date(),
  updatedAt: z.date()
});
// Combined multi-user graph schema
export const multiUserGraphSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  description: z.string().optional(),
  ownerUserId: z.string().uuid(),
  isPublic: z.boolean().default(false),
  contributorIds: z.array(z.string().uuid()),
  nodes: z.array(nodeSchema.extend({
    contributorId: z.string().uuid().optional(),
    sourceGraphId: z.string().uuid().optional()
  })),
  edges: z.array(edgeSchema.extend({
    contributorId: z.string().uuid().optional(),
    sourceGraphId: z.string().uuid().optional()
  })),
  createdAt: z.date(),
  updatedAt: z.date(),
  analyticsEnabled: z.boolean().default(true)
});
Step 2: Create Database Functions
Add functions to manage user graphs:
// server/database.ts - Add these functions
// User graphs
export async function createUserGraph(userId: string, name: string, description: string, graph: Graph) {
  const result = await db.query(
    'INSERT INTO user_graphs (user_id, name, description, nodes, edges) VALUES ($1, $2, $3, $4, $5) RETURNING *',
    [userId, name, description, JSON.stringify(graph.nodes), JSON.stringify(graph.edges)]
  );
  return result.rows[0];
}
export async function getUserGraphs(userId: string) {
  const result = await db.query(
    'SELECT * FROM user_graphs WHERE user_id = $1 ORDER BY updated_at DESC',
    [userId]
  );
  return result.rows;
}
export async function getGraphById(graphId: string) {
  const result = await db.query('SELECT * FROM user_graphs WHERE id = $1', [graphId]);
  if (result.rows.length === 0) {
    throw new Error('Graph not found');
  }
  return result.rows[0];
}
// Multi-user graphs
export async function createMultiUserGraph(ownerUserId: string, name: string, description: string) {
  const result = await db.query(
    'INSERT INTO multi_user_graphs (owner_user_id, name, description, nodes, edges, contributor_ids) VALUES ($1, $2, $3, $4, $5, $6) RETURNING *',
    [ownerUserId, name, description, '[]', '[]', JSON.stringify([ownerUserId])]
  );
  return result.rows[0];
}
export async function getMultiUserGraphs(userId: string) {
  const result = await db.query(
    `SELECT * FROM multi_user_graphs 
     WHERE owner_user_id = $1 OR contributor_ids @> $2
     ORDER BY updated_at DESC`,
    [userId, JSON.stringify([userId])]
  );
  return result.rows;
}
export async function addGraphToMultiUserGraph(multiUserGraphId: string, userGraphId: string, userId: string) {
  // Get the multi-user graph
  const multiUserGraph = await getMultiUserGraphById(multiUserGraphId);
  
  // Check if user is authorized
  if (!multiUserGraph.contributor_ids.includes(userId)) {
    throw new Error('User not authorized to modify this graph');
  }
  
  // Get the user graph
  const userGraph = await getGraphById(userGraphId);
  
  // Add contributor ID to nodes and edges
  const nodesWithContributor = userGraph.nodes.map(node => ({
    ...node,
    contributorId: userId,
    sourceGraphId: userGraphId
  }));
  
  const edgesWithContributor = userGraph.edges.map(edge => ({
    ...edge,
    contributorId: userId,
    sourceGraphId: userGraphId
  }));
  
  // Merge the graphs
  const mergedNodes = [...multiUserGraph.nodes, ...nodesWithContributor];
  const mergedEdges = [...multiUserGraph.edges, ...edgesWithContributor];
  
  // Update the multi-user graph
  const result = await db.query(
    'UPDATE multi_user_graphs SET nodes = $1, edges = $2, updated_at = NOW() WHERE id = $3 RETURNING *',
    [JSON.stringify(mergedNodes), JSON.stringify(mergedEdges), multiUserGraphId]
  );
  
  return result.rows[0];
}
Phase 3: Real-Time Communication with Socket.io
Step 1: Configure Socket.io Server
Set up the Socket.io server:
// server/socket.ts
import { Server } from 'socket.io';
import http from 'http';
import { authenticateToken } from './auth';
export function setupSocketServer(server: http.Server) {
  const io = new Server(server, {
    cors: {
      origin: '*',
      methods: ['GET', 'POST']
    }
  });
  
  // Authentication middleware
  io.use((socket, next) => {
    const token = socket.handshake.auth.token;
    if (!token) {
      return next(new Error('Authentication error'));
    }
    
    try {
      const decoded = authenticateToken(token);
      socket.data.user = decoded;
      next();
    } catch (err) {
      next(new Error('Authentication error'));
    }
  });
  
  // Connection handler
  io.on('connection', (socket) => {
    console.log(`User connected: ${socket.data.user.userId}`);
    
    // Join personal room
    socket.join(`user:${socket.data.user.userId}`);
    
    // Join graph rooms
    socket.on('join-graph', (graphId) => {
      socket.join(`graph:${graphId}`);
      console.log(`User ${socket.data.user.userId} joined graph ${graphId}`);
    });
    
    // Leave graph room
    socket.on('leave-graph', (graphId) => {
      socket.leave(`graph:${graphId}`);
      console.log(`User ${socket.data.user.userId} left graph ${graphId}`);
    });
    
    // Handle graph updates
    socket.on('graph-update', (data) => {
      // Broadcast to all users in the graph room except sender
      socket.to(`graph:${data.graphId}`).emit('graph-updated', {
        graphId: data.graphId,
        update: data.update,
        userId: socket.data.user.userId
      });
    });
    
    // Handle node addition
    socket.on('add-node', (data) => {
      socket.to(`graph:${data.graphId}`).emit('node-added', {
        graphId: data.graphId,
        node: data.node,
        userId: socket.data.user.userId
      });
    });
    
    // Handle edge addition
    socket.on('add-edge', (data) => {
      socket.to(`graph:${data.graphId}`).emit('edge-added', {
        graphId: data.graphId,
        edge: data.edge,
        userId: socket.data.user.userId
      });
    });
    
    // Handle disconnection
    socket.on('disconnect', () => {
      console.log(`User disconnected: ${socket.data.user.userId}`);
    });
  });
  
  return io;
}
Step 2: Update Server Index
Update server/index.ts to use Socket.io:
// Update server/index.ts
import { setupSocketServer } from './socket';
// Add after creating the HTTP server:
const io = setupSocketServer(server);
Step 3: Create Socket.io Client Hook
Create a React hook for client-side Socket.io:
// client/src/hooks/use-socket.ts
import { useEffect, useState } from 'react';
import { io, Socket } from 'socket.io-client';
import { useAuthStore } from '@/stores/auth';
export function useSocket() {
  const [socket, setSocket] = useState<Socket | null>(null);
  const { token, isAuthenticated } = useAuthStore();
  
  useEffect(() => {
    if (!isAuthenticated || !token) {
      return;
    }
    
    // Create socket connection
    const socketInstance = io('/', {
      auth: { token }
    });
    
    socketInstance.on('connect', () => {
      console.log('Socket connected');
    });
    
    socketInstance.on('connect_error', (err) => {
      console.error('Socket connection error:', err.message);
    });
    
    setSocket(socketInstance);
    
    // Cleanup on unmount
    return () => {
      socketInstance.disconnect();
    };
  }, [isAuthenticated, token]);
  
  return socket;
}
Phase 4: Graph Data Science & Analytics Service
Step 1: Create Analytics Service
Create a service for graph analytics:
// server/analytics.ts
import { Graph, Node, Edge } from '@shared/schema';
// Centrality measures
export function calculateDegreeCentrality(graph: Graph) {
  const centrality: Record<string, number> = {};
  
  // Initialize with zero degrees
  graph.nodes.forEach(node => {
    centrality[node.id] = 0;
  });
  
  // Count degrees
  graph.edges.forEach(edge => {
    centrality[edge.source] = (centrality[edge.source] || 0) + 1;
    centrality[edge.target] = (centrality[edge.target] || 0) + 1;
  });
  
  return centrality;
}
export function calculateBetweennessCentrality(graph: Graph) {
  // Placeholder for a more complex betweenness centrality algorithm
  // In a real implementation, this would use a proper graph algorithm library
  const centrality: Record<string, number> = {};
  
  // Initialize
  graph.nodes.forEach(node => {
    centrality[node.id] = 0;
  });
  
  // Simple approximation based on shortest paths
  // (This is a simplified placeholder - real implementation would be more complex)
  graph.nodes.forEach((source) => {
    graph.nodes.forEach((target) => {
      if (source.id !== target.id) {
        const shortestPath = findShortestPath(graph, source.id, target.id);
        if (shortestPath) {
          // Increment centrality for nodes on the path (excluding endpoints)
          shortestPath.slice(1, -1).forEach(nodeId => {
            centrality[nodeId] = (centrality[nodeId] || 0) + 1;
          });
        }
      }
    });
  });
  
  return centrality;
}
export function findCommunities(graph: Graph) {
  // Placeholder for community detection algorithm
  // In a real implementation, this would use a proper graph algorithm library
  // Simple approximation based on connected components
  const visited = new Set<string>();
  const communities: string[][] = [];
  
  graph.nodes.forEach(node => {
    if (!visited.has(node.id)) {
      const community: string[] = [];
      dfs(graph, node.id, visited, community);
      communities.push(community);
    }
  });
  
  return communities;
}
function dfs(graph: Graph, nodeId: string, visited: Set<string>, community: string[]) {
  visited.add(nodeId);
  community.push(nodeId);
  
  // Find all adjacent nodes
  graph.edges.forEach(edge => {
    if (edge.source === nodeId && !visited.has(edge.target)) {
      dfs(graph, edge.target, visited, community);
    }
    if (edge.target === nodeId && !visited.has(edge.source)) {
      dfs(graph, edge.source, visited, community);
    }
  });
}
function findShortestPath(graph: Graph, startId: string, endId: string): string[] | null {
  const queue: {nodeId: string, path: string[]}[] = [{nodeId: startId, path: [startId]}];
  const visited = new Set<string>([startId]);
  
  while (queue.length > 0) {
    const {nodeId, path} = queue.shift()!;
    
    if (nodeId === endId) {
      return path;
    }
    
    // Find all adjacent nodes
    const adjacentNodes = graph.edges
      .filter(edge => edge.source === nodeId || edge.target === nodeId)
      .map(edge => edge.source === nodeId ? edge.target : edge.source);
    
    for (const adjNode of adjacentNodes) {
      if (!visited.has(adjNode)) {
        visited.add(adjNode);
        queue.push({
          nodeId: adjNode,
          path: [...path, adjNode]
        });
      }
    }
  }
  
  return null; // No path found
}
// Graph statistics
export function calculateGraphStatistics(graph: Graph) {
  const nodeCount = graph.nodes.length;
  const edgeCount = graph.edges.length;
  
  // Calculate density
  const density = nodeCount > 1 ? (2 * edgeCount) / (nodeCount * (nodeCount - 1)) : 0;
  
  // Calculate average degree
  const degreeCentrality = calculateDegreeCentrality(graph);
  const degrees = Object.values(degreeCentrality);
  const avgDegree = degrees.reduce((sum, val) => sum + val, 0) / nodeCount;
  
  // Calculate node type distribution
  const nodeTypeDistribution: Record<string, number> = {};
  graph.nodes.forEach(node => {
    const type = node.type || 'unknown';
    nodeTypeDistribution[type] = (nodeTypeDistribution[type] || 0) + 1;
  });
  
  // Calculate edge label distribution
  const edgeLabelDistribution: Record<string, number> = {};
  graph.edges.forEach(edge => {
    const label = edge.label || 'unknown';
    edgeLabelDistribution[label] = (edgeLabelDistribution[label] || 0) + 1;
  });
  
  // Find communities/clusters
  const communities = findCommunities(graph);
  
  return {
    nodeCount,
    edgeCount,
    density,
    avgDegree,
    nodeTypeDistribution,
    edgeLabelDistribution,
    communityCount: communities.length,
    communities: communities.map(c => ({ size: c.length, nodes: c })),
  };
}
// Time-based analytics for multi-user graphs
export function analyzeGraphEvolution(graphSnapshots: Graph[]) {
  if (graphSnapshots.length < 2) {
    return { 
      growthRate: 0,
      nodeAdditions: [],
      edgeAdditions: [],
      evolution: []
    };
  }
  
  const evolution = graphSnapshots.map((snapshot, index) => {
    return {
      timestamp: new Date().toISOString(), // This would be the actual timestamp in a real implementation
      nodeCount: snapshot.nodes.length,
      edgeCount: snapshot.edges.length,
      density: snapshot.nodes.length > 1 
        ? (2 * snapshot.edges.length) / (snapshot.nodes.length * (snapshot.nodes.length - 1)) 
        : 0
    };
  });
  
  // Calculate growth rate
  const firstSnapshot = graphSnapshots[0];
  const lastSnapshot = graphSnapshots[graphSnapshots.length - 1];
  const nodeGrowth = lastSnapshot.nodes.length - firstSnapshot.nodes.length;
  const edgeGrowth = lastSnapshot.edges.length - firstSnapshot.edges.length;
  
  // Track node and edge additions
  const nodeAdditions = graphSnapshots.map((snapshot, index) => {
    if (index === 0) return 0;
    return snapshot.nodes.length - graphSnapshots[index - 1].nodes.length;
  }).slice(1);
  
  const edgeAdditions = graphSnapshots.map((snapshot, index) => {
    if (index === 0) return 0;
    return snapshot.edges.length - graphSnapshots[index - 1].edges.length;
  }).slice(1);
  
  return {
    growthRate: {
      nodes: nodeGrowth,
      edges: edgeGrowth
    },
    nodeAdditions,
    edgeAdditions,
    evolution
  };
}
Step 2: Create Analytics API Endpoints
Add endpoints for analytics:
// Add to server/routes.ts
// Graph analytics endpoints
app.post('/api/graph/analytics', async (req, res) => {
  try {
    const { graph } = req.body;
    
    if (!graph || !Array.isArray(graph.nodes) || !Array.isArray(graph.edges)) {
      return res.status(400).json({ message: 'Invalid graph structure' });
    }
    
    const analytics = calculateGraphStatistics(graph);
    const centrality = calculateDegreeCentrality(graph);
    
    res.json({
      statistics: analytics,
      centrality
    });
  } catch (error) {
    console.error('Error calculating graph analytics:', error);
    res.status(500).json({ message: 'Failed to calculate graph analytics' });
  }
});
app.post('/api/graph/centrality', async (req, res) => {
  try {
    const { graph, type } = req.body;
    
    if (!graph || !Array.isArray(graph.nodes) || !Array.isArray(graph.edges)) {
      return res.status(400).json({ message: 'Invalid graph structure' });
    }
    
    let result;
    switch (type) {
      case 'degree':
        result = calculateDegreeCentrality(graph);
        break;
      case 'betweenness':
        result = calculateBetweennessCentrality(graph);
        break;
      default:
        result = calculateDegreeCentrality(graph);
    }
    
    res.json({ centrality: result });
  } catch (error) {
    console.error('Error calculating centrality:', error);
    res.status(500).json({ message: 'Failed to calculate centrality' });
  }
});
app.post('/api/graph/communities', async (req, res) => {
  try {
    const { graph } = req.body;
    
    if (!graph || !Array.isArray(graph.nodes) || !Array.isArray(graph.edges)) {
      return res.status(400).json({ message: 'Invalid graph structure' });
    }
    
    const communities = findCommunities(graph);
    
    res.json({ communities });
  } catch (error) {
    console.error('Error detecting communities:', error);
    res.status(500).json({ message: 'Failed to detect communities' });
  }
});
// Multi-user graph analytics endpoints
app.get('/api/multi-graph/:id/analytics', async (req, res) => {
  try {
    const { id } = req.params;
    const multiUserGraph = await getMultiUserGraphById(id);
    
    const analytics = calculateGraphStatistics(multiUserGraph);
    const contributorStats = getContributorStatistics(multiUserGraph);
    
    res.json({
      graphStats: analytics,
      contributorStats
    });
  } catch (error) {
    console.error('Error calculating multi-user graph analytics:', error);
    res.status(500).json({ message: 'Failed to calculate multi-user graph analytics' });
  }
});
Phase 5: Multi-User Graph Management
Step 1: Create Management API
Add endpoints for multi-user graph management:
// Add to server/routes.ts
// Multi-user graph management endpoints
app.get('/api/multi-graph', async (req, res) => {
  try {
    // Get user ID from auth token
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) {
      return res.status(401).json({ message: 'Authentication required' });
    }
    
    const decoded = authenticateToken(token);
    const userId = decoded.userId;
    
    // Get all multi-user graphs the user has access to
    const graphs = await getMultiUserGraphs(userId);
    
    res.json(graphs);
  } catch (error) {
    console.error('Error fetching multi-user graphs:', error);
    res.status(500).json({ message: 'Failed to fetch multi-user graphs' });
  }
});
app.post('/api/multi-graph', async (req, res) => {
  try {
    // Get user ID from auth token
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) {
      return res.status(401).json({ message: 'Authentication required' });
    }
    
    const decoded = authenticateToken(token);
    const userId = decoded.userId;
    
    // Create a new multi-user graph
    const { name, description } = req.body;
    const graph = await createMultiUserGraph(userId, name, description);
    
    res.json(graph);
  } catch (error) {
    console.error('Error creating multi-user graph:', error);
    res.status(500).json({ message: 'Failed to create multi-user graph' });
  }
});
app.post('/api/multi-graph/:id/add-user-graph', async (req, res) => {
  try {
    // Get user ID from auth token
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) {
      return res.status(401).json({ message: 'Authentication required' });
    }
    
    const decoded = authenticateToken(token);
    const userId = decoded.userId;
    
    // Add a user graph to a multi-user graph
    const { id } = req.params;
    const { userGraphId } = req.body;
    
    const updatedGraph = await addGraphToMultiUserGraph(id, userGraphId, userId);
    
    // Notify all users in the graph room about the update
    const io = req.app.get('io');
    io.to(`graph:${id}`).emit('graph-updated', {
      graphId: id,
      type: 'add-user-graph',
      userId
    });
    
    res.json(updatedGraph);
  } catch (error) {
    console.error('Error adding user graph:', error);
    res.status(500).json({ message: 'Failed to add user graph' });
  }
});
app.post('/api/multi-graph/:id/add-contributor', async (req, res) => {
  try {
    // Get user ID from auth token
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) {
      return res.status(401).json({ message: 'Authentication required' });
    }
    
    const decoded = authenticateToken(token);
    const userId = decoded.userId;
    
    // Add a contributor to a multi-user graph
    const { id } = req.params;
    const { contributorEmail } = req.body;
    
    // Get the multi-user graph
    const graph = await getMultiUserGraphById(id);
    
    // Check if the user is the owner
    if (graph.owner_user_id !== userId) {
      return res.status(403).json({ message: 'Only the owner can add contributors' });
    }
    
    // Get the user ID from email
    const userResult = await db.query('SELECT id FROM users WHERE email = $1', [contributorEmail]);
    if (userResult.rows.length === 0) {
      return res.status(404).json({ message: 'User not found' });
    }
    
    const contributorId = userResult.rows[0].id;
    
    // Add the contributor
    const contributorIds = graph.contributor_ids || [];
    if (contributorIds.includes(contributorId)) {
      return res.status(400).json({ message: 'User is already a contributor' });
    }
    
    contributorIds.push(contributorId);
    
    // Update the graph
    const result = await db.query(
      'UPDATE multi_user_graphs SET contributor_ids = $1 WHERE id = $2 RETURNING *',
      [JSON.stringify(contributorIds), id]
    );
    
    // Notify all users in the graph room about the new contributor
    const io = req.app.get('io');
    io.to(`graph:${id}`).emit('contributor-added', {
      graphId: id,
      contributorId
    });
    
    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error adding contributor:', error);
    res.status(500).json({ message: 'Failed to add contributor' });
  }
});
Step 2: Create User Graph Management UI
Create components for managing graphs:
// client/src/components/MultiUserGraphManager.tsx
import React, { useState, useEffect } from 'react';
import { useSocket } from '@/hooks/use-socket';
import { useAuthStore } from '@/stores/auth';
import { Button } from '@/components/ui/button';
import { Card, CardHeader, CardTitle, CardContent, CardFooter } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
export default function MultiUserGraphManager() {
  const { token, user } = useAuthStore();
  const socket = useSocket();
  
  const [userGraphs, setUserGraphs] = useState([]);
  const [multiUserGraphs, setMultiUserGraphs] = useState([]);
  const [newGraphName, setNewGraphName] = useState('');
  const [newGraphDescription, setNewGraphDescription] = useState('');
  
  // Fetch user graphs
  useEffect(() => {
    if (!token) return;
    
    const fetchGraphs = async () => {
      try {
        const response = await fetch('/api/user-graphs', {
          headers: { Authorization: `Bearer ${token}` }
        });
        
        if (!response.ok) throw new Error('Failed to fetch graphs');
        
        const data = await response.json();
        setUserGraphs(data);
      } catch (error) {
        console.error('Error fetching user graphs:', error);
      }
    };
    
    fetchGraphs();
  }, [token]);
  
  // Fetch multi-user graphs
  useEffect(() => {
    if (!token) return;
    
    const fetchMultiUserGraphs = async () => {
      try {
        const response = await fetch('/api/multi-graph', {
          headers: { Authorization: `Bearer ${token}` }
        });
        
        if (!response.ok) throw new Error('Failed to fetch multi-user graphs');
        
        const data = await response.json();
        setMultiUserGraphs(data);
      } catch (error) {
        console.error('Error fetching multi-user graphs:', error);
      }
    };
    
    fetchMultiUserGraphs();
  }, [token]);
  
  // Socket events for real-time updates
  useEffect(() => {
    if (!socket) return;
    
    // Listen for graph updates
    socket.on('graph-updated', (data) => {
      // Refresh the multi-user graphs
      fetchMultiUserGraphs();
    });
    
    return () => {
      socket.off('graph-updated');
    };
  }, [socket]);
  
  // Create a new multi-user graph
  const createMultiUserGraph = async () => {
    if (!token || !newGraphName) return;
    
    try {
      const response = await fetch('/api/multi-graph', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`
        },
        body: JSON.stringify({
          name: newGraphName,
          description: newGraphDescription
        })
      });
      
      if (!response.ok) throw new Error('Failed to create multi-user graph');
      
      const newGraph = await response.json();
      setMultiUserGraphs([...multiUserGraphs, newGraph]);
      
      // Reset form
      setNewGraphName('');
      setNewGraphDescription('');
    } catch (error) {
      console.error('Error creating multi-user graph:', error);
    }
  };
  
  // Add a user graph to a multi-user graph
  const addGraphToMultiUser = async (multiUserGraphId, userGraphId) => {
    if (!token) return;
    
    try {
      const response = await fetch(`/api/multi-graph/${multiUserGraphId}/add-user-graph`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`
        },
        body: JSON.stringify({ userGraphId })
      });
      
      if (!response.ok) throw new Error('Failed to add graph');
      
      // Refresh multi-user graphs
      const updatedGraph = await response.json();
      setMultiUserGraphs(multiUserGraphs.map(g => 
        g.id === updatedGraph.id ? updatedGraph : g
      ));
    } catch (error) {
      console.error('Error adding graph to multi-user graph:', error);
    }
  };
  
  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-6">Graph Management</h1>
      
      <Tabs defaultValue="user">
        <TabsList className="mb-4">
          <TabsTrigger value="user">My Graphs</TabsTrigger>
          <TabsTrigger value="multi">Collaborative Graphs</TabsTrigger>
        </TabsList>
        
        <TabsContent value="user">
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {userGraphs.map(graph => (
              <Card key={graph.id}>
                <CardHeader>
                  <CardTitle>{graph.name}</CardTitle>
                </CardHeader>
                <CardContent>
                  <p className="text-sm text-gray-500">{graph.description || 'No description'}</p>
                  <div className="mt-2">
                    <p className="text-xs">Nodes: {graph.nodes.length}</p>
                    <p className="text-xs">Edges: {graph.edges.length}</p>
                  </div>
                </CardContent>
                <CardFooter>
                  <Dialog>
                    <DialogTrigger asChild>
                      <Button variant="outline" size="sm">Share</Button>
                    </DialogTrigger>
                    <DialogContent>
                      <DialogHeader>
                        <DialogTitle>Add to Collaborative Graph</DialogTitle>
                      </DialogHeader>
                      <div className="space-y-4">
                        <p className="text-sm">Select a collaborative graph to add this graph to:</p>
                        <div className="space-y-2">
                          {multiUserGraphs.map(multiGraph => (
                            <Button 
                              key={multiGraph.id}
                              variant="outline"
                              className="w-full justify-start"
                              onClick={() => addGraphToMultiUser(multiGraph.id, graph.id)}
                            >
                              {multiGraph.name}
                            </Button>
                          ))}
                        </div>
                      </div>
                    </DialogContent>
                  </Dialog>
                  <Button variant="default" size="sm" className="ml-2">
                    View
                  </Button>
                </CardFooter>
              </Card>
            ))}
          </div>
        </TabsContent>
        
        <TabsContent value="multi">
          <div className="mb-6">
            <Card>
              <CardHeader>
                <CardTitle>Create New Collaborative Graph</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  <div>
                    <Label htmlFor="graphName">Graph Name</Label>
                    <Input 
                      id="graphName"
                      value={newGraphName}
                      onChange={(e) => setNewGraphName(e.target.value)}
                      placeholder="Enter graph name"
                    />
                  </div>
                  <div>
                    <Label htmlFor="graphDescription">Description</Label>
                    <Input 
                      id="graphDescription"
                      value={newGraphDescription}
                      onChange={(e) => setNewGraphDescription(e.target.value)}
                      placeholder="Enter description"
                    />
                  </div>
                </div>
              </CardContent>
              <CardFooter>
                <Button onClick={createMultiUserGraph}>Create Collaborative Graph</Button>
              </CardFooter>
            </Card>
          </div>
          
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {multiUserGraphs.map(graph => (
              <Card key={graph.id}>
                <CardHeader>
                  <CardTitle>{graph.name}</CardTitle>
                </CardHeader>
                <CardContent>
                  <p className="text-sm text-gray-500">{graph.description || 'No description'}</p>
                  <div className="mt-2">
                    <p className="text-xs">Nodes: {graph.nodes.length}</p>
                    <p className="text-xs">Edges: {graph.edges.length}</p>
                    <p className="text-xs">Contributors: {graph.contributor_ids.length}</p>
                  </div>
                </CardContent>
                <CardFooter>
                  <Button variant="outline" size="sm">
                    Analytics
                  </Button>
                  <Button variant="default" size="sm" className="ml-2">
                    View
                  </Button>
                </CardFooter>
              </Card>
            ))}
          </div>
        </TabsContent>
      </Tabs>
    </div>
  );
}
Phase 6: Graph Data Science Visualization
Step 1: Create Graph Analytics Components
Create components for visualizing graph analytics:
// client/src/components/GraphAnalytics.tsx
import React, { useState, useEffect } from 'react';
import { useAuthStore } from '@/stores/auth';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { 
  BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, 
  ResponsiveContainer, PieChart, Pie, Cell, LineChart, Line 
} from 'recharts';
export default function GraphAnalytics({ graph, multiUserGraph = false }) {
  const { token } = useAuthStore();
  const [analytics, setAnalytics] = useState(null);
  const [centrality, setCentrality] = useState(null);
  const [communities, setCommunities] = useState(null);
  const [loading, setLoading] = useState(true);
  
  // Fetch graph analytics
  useEffect(() => {
    if (!graph || !token) return;
    
    const fetchAnalytics = async () => {
      setLoading(true);
      try {
        // Basic graph statistics
        const statsResponse = await fetch('/api/graph/analytics', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${token}`
          },
          body: JSON.stringify({ graph })
        });
        
        if (!statsResponse.ok) throw new Error('Failed to fetch analytics');
        
        const statsData = await statsResponse.json();
        setAnalytics(statsData.statistics);
        setCentrality(statsData.centrality);
        
        // Community detection
        const commResponse = await fetch('/api/graph/communities', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${token}`
          },
          body: JSON.stringify({ graph })
        });
        
        if (!commResponse.ok) throw new Error('Failed to detect communities');
        
        const commData = await commResponse.json();
        setCommunities(commData.communities);
      } catch (error) {
        console.error('Error fetching graph analytics:', error);
      } finally {
        setLoading(false);
      }
    };
    
    fetchAnalytics();
  }, [graph, token]);
  
  // Format node type distribution for charts
  const nodeTypeData = analytics ? 
    Object.entries(analytics.nodeTypeDistribution).map(([type, count]) => ({
      name: type,
      value: count
    })) : [];
  
  // Format edge label distribution for charts
  const edgeLabelData = analytics ? 
    Object.entries(analytics.edgeLabelDistribution).map(([label, count]) => ({
      name: label,
      value: count
    })) : [];
  
  // Format centrality data for charts
  const centralityData = centrality ? 
    Object.entries(centrality).map(([nodeId, value]) => {
      // Find the node to get its label
      const node = graph.nodes.find(n => n.id === nodeId);
      return {
        name: node ? (node.properties.name || node.label) : nodeId,
        value: value
      };
    })
    .sort((a, b) => b.value - a.value)
    .slice(0, 10) : []; // Top 10 nodes by centrality
  
  // Format community data
  const communityData = communities ? 
    communities.map((community, index) => ({
      name: `Community ${index + 1}`,
      value: community.length
    })) : [];
  
  // Colors for charts
  const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042', '#8884d8', '#82ca9d'];
  
  return (
    <div className="p-4">
      <h2 className="text-xl font-bold mb-4">Graph Analytics</h2>
      
      {loading ? (
        <div className="text-center py-8">Loading analytics...</div>
      ) : (
        <Tabs defaultValue="overview">
          <TabsList className="mb-4">
            <TabsTrigger value="overview">Overview</TabsTrigger>
            <TabsTrigger value="centrality">Centrality</TabsTrigger>
            <TabsTrigger value="communities">Communities</TabsTrigger>
            {multiUserGraph && <TabsTrigger value="contributors">Contributors</TabsTrigger>}
          </TabsList>
          
          <TabsContent value="overview">
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
              <Card>
                <CardHeader className="pb-2">
                  <CardTitle className="text-lg">Basic Statistics</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="space-y-2">
                    <div className="flex justify-between">
                      <span className="text-sm text-gray-500">Nodes:</span>
                      <span className="font-medium">{analytics?.nodeCount}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-sm text-gray-500">Edges:</span>
                      <span className="font-medium">{analytics?.edgeCount}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-sm text-gray-500">Density:</span>
                      <span className="font-medium">{analytics?.density.toFixed(4)}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-sm text-gray-500">Avg. Degree:</span>
                      <span className="font-medium">{analytics?.avgDegree.toFixed(2)}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-sm text-gray-500">Communities:</span>
                      <span className="font-medium">{analytics?.communityCount}</span>
                    </div>
                  </div>
                </CardContent>
              </Card>
              
              <Card className="col-span-1 md:col-span-2">
                <CardHeader className="pb-2">
                  <CardTitle className="text-lg">Node Type Distribution</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="h-72">
                    <ResponsiveContainer width="100%" height="100%">
                      <PieChart>
                        <Pie
                          data={nodeTypeData}
                          cx="50%"
                          cy="50%"
                          labelLine={true}
                          label={({ name, percent }) => `${name} (${(percent * 100).toFixed(0)}%)`}
                          outerRadius={80}
                          fill="#8884d8"
                          dataKey="value"
                        >
                          {nodeTypeData.map((entry, index) => (
                            <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                          ))}
                        </Pie>
                        <Tooltip />
                        <Legend />
                      </PieChart>
                    </ResponsiveContainer>
                  </div>
                </CardContent>
              </Card>
            </div>
            
            <Card>
              <CardHeader className="pb-2">
                <CardTitle className="text-lg">Edge Label Distribution</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="h-80">
                  <ResponsiveContainer width="100%" height="100%">
                    <BarChart data={edgeLabelData}>
                      <CartesianGrid strokeDasharray="3 3" />
                      <XAxis dataKey="name" />
                      <YAxis />
                      <Tooltip />
                      <Legend />
                      <Bar dataKey="value" fill="#8884d8" />
                    </BarChart>
                  </ResponsiveContainer>
                </div>
              </CardContent>
            </Card>
          </TabsContent>
          
          <TabsContent value="centrality">
            <Card>
              <CardHeader className="pb-2">
                <CardTitle className="text-lg">Top Nodes by Centrality</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="h-96">
                  <ResponsiveContainer width="100%" height="100%">
                    <BarChart
                      data={centralityData}
                      layout="vertical"
                      margin={{ top: 5, right: 30, left: 100, bottom: 5 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" />
                      <XAxis type="number" />
                      <YAxis type="category" dataKey="name" />
                      <Tooltip />
                      <Legend />
                      <Bar dataKey="value" fill="#82ca9d" />
                    </BarChart>
                  </ResponsiveContainer>
                </div>
              </CardContent>
            </Card>
          </TabsContent>
          
          <TabsContent value="communities">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <Card>
                <CardHeader className="pb-2">
                  <CardTitle className="text-lg">Community Sizes</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="h-72">
                    <ResponsiveContainer width="100%" height="100%">
                      <PieChart>
                        <Pie
                          data={communityData}
                          cx="50%"
                          cy="50%"
                          labelLine={true}
                          label={({ name, percent }) => `${name} (${(percent * 100).toFixed(0)}%)`}
                          outerRadius={80}
                          fill="#8884d8"
                          dataKey="value"
                        >
                          {communityData.map((entry, index) => (
                            <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                          ))}
                        </Pie>
                        <Tooltip />
                      </PieChart>
                    </ResponsiveContainer>
                  </div>
                </CardContent>
              </Card>
              
              <Card>
                <CardHeader className="pb-2">
                  <CardTitle className="text-lg">Communities</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="space-y-4 max-h-72 overflow-auto">
                    {communities?.map((community, index) => (
                      <div key={index} className="border p-3 rounded">
                        <h3 className="font-medium mb-2">Community {index + 1}</h3>
                        <p className="text-sm">Nodes: {community.length}</p>
                        <div className="mt-2 text-xs text-gray-500">
                          Top nodes: {community.slice(0, 3).map(nodeId => {
                            const node = graph.nodes.find(n => n.id === nodeId);
                            return node ? (node.properties.name || node.label) : nodeId;
                          }).join(', ')}
                          {community.length > 3 && `, and ${community.length - 3} more`}
                        </div>
                      </div>
                    ))}
                  </div>
                </CardContent>
              </Card>
            </div>
          </TabsContent>
          
          {multiUserGraph && (
            <TabsContent value="contributors">
              <Card>
                <CardHeader className="pb-2">
                  <CardTitle className="text-lg">Contributor Analytics</CardTitle>
                </CardHeader>
                <CardContent>
                  <p>This tab would show contributor-specific analytics for multi-user graphs</p>
                </CardContent>
              </Card>
            </TabsContent>
          )}
        </Tabs>
      )}
    </div>
  );
}
Phase 7: Update App Routes and Navigation
Step 1: Update App.tsx
Update the main App.tsx file to include new routes:
// client/src/App.tsx
import { Switch, Route } from "wouter";
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import NotFound from "@/pages/not-found";
import Home from "@/pages/Home";
import LogsPage from "@/pages/Logs";
import GraphV2 from "@/pages/GraphV2";
import LogTest from "@/pages/LogTest";
import TextToGraphAnatomy from "@/pages/TextToGraphAnatomy";
import WebSearchAnatomy from "@/pages/WebSearchAnatomy";
import UIShowcase from "@/pages/UIShowcase";
import Header from "@/components/Header";
import Auth from "@/pages/Auth";
import UserGraphs from "@/pages/UserGraphs";
import MultiUserGraphs from "@/pages/MultiUserGraphs";
import GraphDataScience from "@/pages/GraphDataScience";
import { useAuthStore } from "@/stores/auth";
function Router() {
  const { isAuthenticated } = useAuthStore();
  
  return (
    <div className="flex flex-col min-h-screen">
      <Header />
      <div className="flex-1">
        <Switch>
          <Route path="/" component={Home} />
          <Route path="/auth" component={Auth} />
          <Route path="/logs" component={LogsPage} />
          <Route path="/graph-v2" component={GraphV2} />
          <Route path="/log-test" component={LogTest} />
          <Route path="/text-to-graph-anatomy" component={TextToGraphAnatomy} />
          <Route path="/web-search-anatomy" component={WebSearchAnatomy} />
          <Route path="/ui-showcase" component={UIShowcase} />
          
          {/* Protected routes */}
          {isAuthenticated && (
            <>
              <Route path="/user-graphs" component={UserGraphs} />
              <Route path="/multi-user-graphs" component={MultiUserGraphs} />
              <Route path="/graph-data-science" component={GraphDataScience} />
            </>
          )}
          
          <Route component={NotFound} />
        </Switch>
      </div>
    </div>
  );
}
function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Router />
      <Toaster />
    </QueryClientProvider>
  );
}
export default App;
Step 2: Update Header Component
Update the Header component to include new navigation links:
// client/src/components/Header.tsx
import { Link, useLocation } from "wouter";
import { useAuthStore } from "@/stores/auth";
export default function Header() {
  const [location] = useLocation();
  const { isAuthenticated, user, logout } = useAuthStore();
  
  return (
    <header className="bg-white border-b shadow-sm py-3">
      <div className="container mx-auto px-4 flex justify-between items-center">
        <div className="flex items-center space-x-6">
          <Link href="/">
            <a className="text-xl font-bold">Graph Explorer</a>
          </Link>
          
          <nav className="hidden md:flex space-x-4">
            <Link href="/">
              <a className={`text-sm ${location === '/' ? 'font-medium text-blue-600' : 'text-gray-600 hover:text-blue-600'}`}>
                Home
              </a>
            </Link>
            
            {isAuthenticated && (
              <>
                <Link href="/user-graphs">
                  <a className={`text-sm ${location === '/user-graphs' ? 'font-medium text-blue-600' : 'text-gray-600 hover:text-blue-600'}`}>
                    My Graphs
                  </a>
                </Link>
                
                <Link href="/multi-user-graphs">
                  <a className={`text-sm ${location === '/multi-user-graphs' ? 'font-medium text-blue-600' : 'text-gray-600 hover:text-blue-600'}`}>
                    Collaborative
                  </a>
                </Link>
                
                <Link href="/graph-data-science">
                  <a className={`text-sm ${location === '/graph-data-science' ? 'font-medium text-blue-600' : 'text-gray-600 hover:text-blue-600'}`}>
                    Data Science
                  </a>
                </Link>
              </>
            )}
            
            <Link href="/ui-showcase">
              <a className={`text-sm ${location === '/ui-showcase' ? 'font-medium text-blue-600' : 'text-gray-600 hover:text-blue-600'}`}>
                UI Showcase
              </a>
            </Link>
          </nav>
        </div>
        
        <div className="flex items-center space-x-4">
          {isAuthenticated ? (
            <div className="flex items-center space-x-4">
              <span className="text-sm text-gray-600">
                {user?.username || user?.email}
              </span>
              <button
                onClick={logout}
                className="text-sm text-red-600 hover:text-red-800"
              >
                Logout
              </button>
            </div>
          ) : (
            <Link href="/auth">
              <a className="text-sm text-blue-600 hover:text-blue-800">
                Login / Register
              </a>
            </Link>
          )}
        </div>
      </div>
    </header>
  );
}
Implementation Summary
This comprehensive plan transforms your existing graph application into a collaborative multi-user experience with advanced graph data science capabilities. Key features include:
1.	User Authentication System
•	Secure login/register with JWT authentication
•	User profiles and session management
2.	Multi-User Graph Schema
•	Individual user graphs with ownership
•	Combined multi-user graphs with contributor tracking
•	Subgraph identification for tracking contributions
3.	Real-Time Communication
•	Socket.io for live updates between users
•	Real-time graph modifications
•	Live collaborative editing
4.	Graph Data Science & Analytics
•	Node centrality measurements
•	Community detection
•	Graph statistics and metrics
•	Time-based analytics for tracking graph evolution
5.	Multi-User Graph Management
•	Creating and sharing graphs
•	Adding contributors
•	Merging individual graphs into collaborative graphs
6.	Graph Analytics Visualization
•	Interactive charts and visualizations
•	Statistical analysis of graph structure
•	Community visualization
To implement this plan, you'll need to install these packages (which you've already done):
•	socket.io and socket.io-client for real-time communication
•	bcryptjs and jsonwebtoken for authentication
•	zustand for state management
•	cors for cross-origin resource sharing
This architecture provides a solid foundation for a collaborative graph experience while maintaining the core functionality of your existing application.

